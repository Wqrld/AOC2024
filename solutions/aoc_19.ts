const fs = require("fs");

// Prepare input
let [inputParts, inputCombinations] = fs.readFileSync("inputs_prod/19.txt", "utf8").split("\n\n");
const parts = inputParts.split(", ");
const combinations = inputCombinations.split("\n");

/**
 * Check if the set of parts is able to generate the fullt arget set
 * @param combinationset Target set
 * @param parts set of parts
 * @returns true/false
 */
function isGeneratingSet(combinationset, parts) {
    return combinationset.every(combination => fitRecursive(combination, parts));
}

/**
 * Calculate a generating set of parts
 * @param parts target set
 * @returns smaller set (not necessarily minimal) that can generate the target set
 */
function calculateGeneratingSet(parts) {
    let tryParts = structuredClone(parts);

    for (let i = 0; i < 1000; i++) {
        let first = tryParts.shift();
        if (!isGeneratingSet(parts, tryParts)) {
            tryParts.push(first); // if removing this part makes it impossible to generate the full set, we need to keep it.
        }
    }
    return tryParts;
}

/**
 * Recursively check if toGenerate can be generated by concatenating parts
 * @param toGenerate  string to generate
 * @param parts  list of string parts to use
 * @returns wheter or not toGenerate can be generated by concatenating parts
 */
function fitRecursive(toGenerate: string, parts: string[]): boolean {
    if (toGenerate == "") {
        return true;
    }
    for (const part of parts) {
        if (toGenerate.startsWith(part)) {
            const sliced = toGenerate.slice(part.length);
            if (fitRecursive(sliced, parts)) {
                return true;
            }
        }
    }

    return false;
}

const generatingSet = calculateGeneratingSet(parts);
console.log("PT 1:", combinations.reduce((acc, combination) => acc + (fitRecursive(combination, generatingSet) ? 1 : 0), 0));

/**
 * Recursively test how many ways there are to build toGenerate by concatenating parts
 * @param toGenerate string to generate
 * @param parts list of string parts to use
 * @returns [possibilities, success] where possibilities is the number of ways to generate toGenerate and success is whether it is possible to generate toGenerate
 */
function fitRecursiveCaching(toGenerate: string, parts: string[]): [number, boolean] {
    if (toGenerate in cache) return cache[toGenerate];
    if (toGenerate == "") return [1, true]

    let possibilities = 0

    for (const part of parts.filter(part => toGenerate.startsWith(part))) {
        const sliced = toGenerate.slice(part.length);
        const [possibilitiesCount, success] = fitRecursiveCaching(sliced, parts);
        cache[sliced] = [possibilitiesCount, success];
        if (success) {
            possibilities += possibilitiesCount;
        }
    }

    if (possibilities > 0) {
        cache[toGenerate] = [possibilities, true];
        return [possibilities, true];
    } else {
        cache[toGenerate] = [999999, false];
        return [999999, false];
    }

}

// Memoization cache for part 2
const cache: { [k: string]: [number, boolean] } = {}

// Calculate and time part 2
const startTime = performance.now();
const sum = combinations.reduce((acc, combi) => {
    const [count, success] = fitRecursiveCaching(combi, parts);
    return acc + (success ? count : 0);
}, 0);
const endTime = performance.now();

console.log("PT 2:", sum);
console.log("PT 2 Time:", (endTime - startTime).toFixed(), "ms")